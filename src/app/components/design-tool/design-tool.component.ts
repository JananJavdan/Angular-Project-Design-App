import { AfterViewInit, Component, OnInit } from '@angular/core';
import { DesignService } from '../../services/design.service';
import { FormsModule } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatInputModule } from '@angular/material/input';
import { MatListModule } from '@angular/material/list';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { CommonModule } from '@angular/common';
import { Design } from '../../models/design.model';
import { RouterModule } from '@angular/router';
import * as fabric from 'fabric';

@Component({
  selector: 'app-design-list',
  standalone: true,
  imports: [
    FormsModule,
    MatButtonModule,
    MatInputModule,
    MatListModule,
    MatProgressSpinnerModule,
    CommonModule,
    RouterModule
  ],
  templateUrl: './design-tool.component.html',
  styleUrls: ['./design-tool.component.css'],
})
export class DesignToolComponent implements OnInit, AfterViewInit {

  private canvas!: fabric.Canvas;
  designs: Design[] = [];

  private state: string[] = []; 
  private mods: number = -1;
  private undoSteps: number = 0; 

  customText: string = '';
  selectedShape: string = 'rectangle'; 
  selectedColor: string = '#ff0000';

  isLoading = true;
  errorMessage: string = '';
  showCreateForm = false;

  newDesign: Design = {
    id: 0, // This will be generated by the backend
    name: '',
    category: '',
    color: '',
    size: '',
    logo: '',
    text: '',
    logoPosition: '',
    font: '',
    customer: null,
    designManager: null,
    approved: false,
    title: '',
    description: '',
    imageUrl: '',
    image: '',
  };
  selectedFile!: Blob;

  constructor(private designService: DesignService) {}

  ngOnInit(): void {}

  ngAfterViewInit(): void {
    this.canvas = new fabric.Canvas('canvas', {
      width: 800,
      height: 600,
      backgroundColor: '#ffffff',
    });
    this.canvas.on('object:added', () => this.saveState());
    this.canvas.on('object:modified', () => this.saveState());
    this.canvas.on('object:removed', () => this.saveState());

    // Initialize the state with the initial empty canvas
    this.saveState();
    window.addEventListener('keydown', (event: KeyboardEvent) => {
      if (event.key === 'Delete' || event.key === 'Backspace') {
        this.deleteSelectedObject();
      }
    });
  }

  saveState(): void {
    const currentState = JSON.stringify(this.canvas.toJSON());
    
    // Verwijder toekomstige undo-states als er nieuwe wijzigingen zijn
    if (this.undoSteps > 0) {
      this.state = this.state.slice(0, this.state.length - this.undoSteps);
      this.undoSteps = 0;
    }

    // Voeg nieuwe state toe als deze verschilt van de laatste opgeslagen state
    if (this.state.length === 0 || currentState !== this.state[this.state.length - 1]) {
      this.state.push(currentState);
      this.mods = this.state.length - 1; // Update de mods naar het nieuwste punt
    }
  }

  undo(): void {
    if (this.mods > 0) {
      this.mods -= 1;
      this.undoSteps += 1; // Tel een undo actie
      const stateToRestore = this.state[this.mods];
      this.canvas.clear();
      this.canvas.loadFromJSON(stateToRestore, () => {
        this.canvas.renderAll(); // Render de canvas na het laden van de vorige state
      });
    }
  }

  redo(): void {
    if (this.undoSteps > 0) {
      this.mods += 1;
      this.undoSteps -= 1; // Verminder het aantal undo-stappen
      const stateToRestore = this.state[this.mods];
      this.canvas.clear();
      this.canvas.loadFromJSON(stateToRestore, () => {
        this.canvas.renderAll(); // Render de canvas opnieuw na het laden van de volgende state
      });
    }
  }
  deleteSelectedObject(): void {
    const activeObject = this.canvas.getActiveObject();
    if (activeObject) {
      this.canvas.remove(activeObject);
      this.saveState();  // Sla de state op na het verwijderen van een object
    }
  }
  
  addShape(): void {
    let shape: fabric.Object;

    switch (this.selectedShape) {
      case 'rectangle':
        shape = new fabric.Rect({
          left: 100,
          top: 100,
          fill: this.selectedColor,
          width: 100,
          height: 60,
        });
        break;

      case 'circle':
        shape = new fabric.Circle({
          left: 100,
          top: 100,
          fill: this.selectedColor,
          radius: 50,
        });
        break;

      case 'triangle':
        shape = new fabric.Triangle({
          left: 100,
          top: 100,
          fill: this.selectedColor,
          width: 100,
          height: 100,
        });
        break;

      default:
        return; // If no shape is selected, do nothing
    }

    this.canvas.add(shape);
    this.saveState(); // State opslaan na het toevoegen van een shape
  }

  triggerImageUpload(): void {
    document.getElementById('imageUpload')?.click();
  }

  onImageUpload(event: any): void {
    const file = event.target.files[0];
    const reader = new FileReader();
  
    reader.onload = (e: any) => {
      const imgElement = new Image();
      imgElement.src = e.target.result;
  
      imgElement.onload = () => {
        const imgInstance = new fabric.Image(imgElement, {
          scaleX: 0.5,
          scaleY: 0.5,
          left: 100,
          top: 100,
        });
        this.canvas.add(imgInstance);
      };
    };
  
    reader.readAsDataURL(file);
  }
  

  download(): void {
    const dataUrl = this.canvas.toDataURL({
      format: 'png',
      multiplier: 1,
    });
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = 'design.png';
    link.click();
  }

  save(): void {
    const formData = new FormData();
    formData.append('color', this.newDesign.color || '');
    formData.append('font', this.newDesign.font || '');
  
    if (this.selectedFile) {
      formData.append('image', this.selectedFile);
    }
  
    this.designService.createDesign(formData).subscribe(
      (response: any) => {
        console.log('Design submitted successfully', response);
      },
      (error: any) => {
        console.error('Failed to submit design', error);
      }
    );
  } 
  
  addText(): void {
    const userText = prompt('Enter the text you want to add:');
    
    if (userText) {
      const text = new fabric.Text(userText, { 
        left: 100, 
        top: 100,
        fill: this.selectedColor, // Voeg kleur toe als optie
      });
      this.canvas.add(text);
      this.saveState();  // Sla de state op na het toevoegen van tekst
    }
  }
  toggleBold(): void {
    const activeObject = this.canvas.getActiveObject() as fabric.Text;
    if (activeObject && activeObject.type === 'text') {
      activeObject.fontWeight = activeObject.fontWeight === 'bold' ? 'normal' : 'bold';
      this.canvas.renderAll();
    }
  }
  
  toggleItalic(): void {
    const activeObject = this.canvas.getActiveObject() as fabric.Text;
    if (activeObject && activeObject.type === 'text') {
      activeObject.fontStyle = activeObject.fontStyle === 'italic' ? 'normal' : 'italic';
      this.canvas.renderAll();
    }
  }
  

  chooseBackgroundColor(): void {
    // Open de verborgen color picker
    const colorPicker = document.getElementById('backgroundColorPicker') as HTMLInputElement;
    if (colorPicker) {
      colorPicker.click();
    }
  }
  
  setBackgroundColor(event: any): void {
    const chosenColor = event.target.value; // Haal de gekozen kleur op
    this.canvas.backgroundColor = chosenColor; // Stel de achtergrondkleur in
    this.canvas.renderAll(); // Render de canvas opnieuw met de nieuwe achtergrondkleur
  }
  

  
  
}
